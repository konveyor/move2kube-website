(()=>{"use strict";var e,o,t={408:(e,o,t)=>{var r=t(152);class s extends r.Fd{constructor(){super()}fd_write(e,o){let t=0;for(let r of o){const o=e.slice(r.buf,r.buf+r.buf_len);self.postMessage({type:n,payload:o}),t+=r.buf_len}return{ret:0,nwritten:t}}}const n="terminal-print",a="transform-error",l="wasi_snapshot_preview1";let c=null,i=null,m=null;const f=["fd_advise","fd_allocate","fd_close","fd_datasync","fd_fdstat_get","fd_fdstat_set_flags","fd_fdstat_set_rights","fd_filestat_get","fd_filestat_set_size","fd_filestat_set_times","fd_pread","fd_prestat_dir_name","fd_prestat_get","fd_pwrite","fd_read","fd_readdir","fd_renumber","fd_seek","fd_sync","fd_tell","fd_write"],u=["fd_readdir","fd_read","fd_pread","fd_write","fd_pwrite"],d={load_time:0,execution_time:0,memory_usage_start:0,memory_usage_end:0,io_count:0,io_time:0,call_counts:{},call_durations:{},custom_transformer_times:{}},p=(e,o)=>({id:e,path:o,countAllocate:0,countDirDetect:0,countTransform:0,tCompile:0,tInstantiate:0,tStart:0,tAllocate:0,tDirDetect:0,tTransform:0,tLoad:0,tExec:0}),_=()=>{d.load_time=0,d.execution_time=0,d.memory_usage_start=0,d.memory_usage_end=0,d.io_count=0,d.io_time=0,d.call_counts={},d.call_durations={},f.forEach((e=>{d.call_counts[e]=0,d.call_durations[e]=0}));const e={};for(const o in d.custom_transformer_times){const t=d.custom_transformer_times[o];e[o]=p(o,t.path),e[o].tCompile=t.tCompile,e[o].tInstantiate=t.tInstantiate,e[o].tStart=t.tStart}d.custom_transformer_times=e};_();const w=e=>{console.log("proxyHostFn start self.crossOriginIsolated",self.crossOriginIsolated),f.forEach((o=>{const t=e[o];e[o]=(...e)=>{d.call_counts[o]++;const r=performance.now(),s=t(...e),n=performance.now()-r;return d.call_durations[o]+=n,s}})),console.log("proxyHostFn end")},g=(e,o,t,r)=>(console.log("poll_oneoff in_, out, nsubscriptions, nevents",e,o,t,r),0),y=(e,o,t,r)=>(console.log("sock_accept sock, fd_flags, ro_fd, ro_addr",e,o,t,r),0),h=async e=>{console.log("processMessage start");try{const o=e.data;switch(console.log("got a message:",o),o.type){case"initialize-worker":{console.log("MSG_INIT_WORKER payload:",o.payload);const{sab:e}=o.payload;console.log("sab",e),e&&(c=new Uint8Array(e),i=new Int32Array(e)),self.postMessage({type:"worker-initialized"});break}case"wasm-module":{console.log("got a wasm module:",typeof o.payload,o.payload);const{wasmModule:t,srcFilename:n,srcContents:f,custFilename:h,custContents:b,configFilename:x,configContents:k,qaSkip:v,enableMetrics:E}=o.payload,I=["move2kube","transform","--source",n,"--output","my-m2k-output"],M={[n]:new r.ZH(f)};v&&I.push("--qa-skip"),h&&b&&(I.push("--customizations",h),M[h]=new r.ZH(b)),x&&k&&(I.push("--config",x),M[x]=new r.ZH(k));const O=[],S=[new s,new s,new s,new r.xy("/",M)];m=S;const D=new r.bJ(I,O,S,{debug:!1}),T=D.wasiImport;T.poll_oneoff=g,T.sock_accept=y,E&&w(T);let A=null;const j=(e,o)=>{if(!A)throw new Error("load_string: the wasm instance is missing");const t=new Uint8Array(A.exports.memory.buffer).slice(e,e+o);return{buf:t,s:new TextDecoder("utf-8").decode(t)}},J=(e,o)=>{if(!A)throw new Error("store_bytes: the wasm instance is missing");new Uint8Array(A.exports.memory.buffer).set(e,o)};let C=0;const L={},z=(e,o)=>{const t=C+1,{s}=j(e,o),n=S[3];console.log("[DEBUG] load_wasm_module called with path:",s,"preOpenedFd:",n);let a=n.dir.contents;if(s.split("/").forEach((e=>{if(""!==e){if(!(e in a))throw console.error("load_wasm_module: p",e,"currDirectoryOrFile",a),new Error("load_wasm_module: failed to find the wasm module");a=a[e],a instanceof r.xy?a=a.dir.contents:a instanceof r.__&&(a=a.contents)}})),!(a instanceof r.ZH))throw new Error("load_wasm_module: the given path is not a file");const c=a.data;console.log("load_wasm_module: wasmModuleBytes",c);const i=performance.now(),m=new WebAssembly.Module(c),f=performance.now()-i;d.custom_transformer_times[t]=p(t,s),d.custom_transformer_times[t].tCompile=f,console.log("create a personal WASI instance for the custom wasm module/transformer");const u=new r.bJ(I,O,S,{debug:!1}),_=u.wasiImport;_.poll_oneoff=g,_.sock_accept=y,E&&w(_);const h={[l]:_},b=performance.now(),x=new WebAssembly.Instance(m,h),k=performance.now()-b;d.custom_transformer_times[t].tInstantiate=k,console.log("load_wasm_module wasi.start start");const v=performance.now();u.start(x);const M=performance.now()-v;return d.custom_transformer_times[t].tStart=M,console.log("load_wasm_module wasi.start done"),console.log("load_wasm_module: compiled wasm and made an instance:",x,"module id:",t),C=t,L[t]=x,t},U=e=>(o,t,r,s)=>{if(console.log("run_transform start is_dir_detect:",e),!(o in L))throw new Error(`There is no wasm module with id ${o}`);const n=L[o],{buf:a,s:l}=j(t,r);console.log("run_transform: load_string buf",a),JSON.parse(l),console.log("run_transform called with: wasmModuleId:",o,"wasmModule",n);const c=a.byteLength;console.log("run_transform: allocate some memory of size:",c);const i=performance.now(),m=n.exports.myAllocate(c),f=performance.now()-i;if(d.custom_transformer_times[o].tAllocate+=f,d.custom_transformer_times[o].countAllocate++,console.log("run_transform: ptr",m,"len",c),m<0)throw new Error("failed to allocate, invalid pointer into memory");let u=new Uint8Array(n.exports.memory.buffer);u.set(a,m),console.log("run_transform: json input set at ptr",m),console.log("run_transform: allocate space for the output pointers");const p=n.exports.myAllocate(8);if(console.log("run_transform: ptrptr",p),p<0)throw new Error("failed to allocate, invalid pointer into memory");if(e){console.log("calling custom transformer directory detect");const e=performance.now(),t=n.exports.RunDirectoryDetect(m,c,p,p+4),r=performance.now()-e;if(d.custom_transformer_times[o].tDirDetect+=r,d.custom_transformer_times[o].countDirDetect++,console.log("run_transform: directory detect result",t),t<0)throw new Error("run_transform: directory detect failed")}else{console.log("calling custom transformer transform");const e=performance.now(),t=n.exports.RunTransform(m,c,p,p+4),r=performance.now()-e;if(d.custom_transformer_times[o].tTransform+=r,d.custom_transformer_times[o].countTransform++,console.log("run_transform: transformation result",t),t<0)throw new Error("run_transform: transformation failed")}const _=new DataView(n.exports.memory.buffer,p,4).getUint32(0,!0),w=new DataView(n.exports.memory.buffer,p+4,4).getUint32(0,!0);console.log("run_transform: transformation outJsonPtr",_,"outJsonLen",w),u=new Uint8Array(n.exports.memory.buffer),console.log("run_transform: memory",u);const g=u.slice(_,_+w);console.log("run_transform: outJsonBytes",g);const y=new TextDecoder("utf-8").decode(g);console.log("run_transform: outJson",y);const h=JSON.parse(y);return console.log("run_transform: outJsonParsed",h),J(g,s),console.log("run_transform end"),g.length},F=(e,o,t)=>{if(t<0)throw new Error("the output pointer is an invalid pointer into memory");const{s:r}=j(e,o),s=JSON.parse(r);console.log("ask the main thread to ask the question:",s),self.postMessage({type:"ask-question",payload:s}),console.log("ask_question: wait until the question is answered");const n=Atomics.wait(i,0,0);if(console.log("ask_question: waitOk:",n),"ok"!==n)throw new Error(`Atomics.wait failed waitOk: ${n}`);const a=((e,o)=>{const t=o[1];if(t<=0)throw new Error("object length is zero or negative");const r=e.slice(8,8+t),s=(new TextDecoder).decode(r);return JSON.parse(s)})(c,i);console.log("got an answer from main thread, ans:",a);const l=JSON.stringify(a),m=(new TextEncoder).encode(l);return J(m,t),m.byteLength},q={[l]:T,mym2kmodule:{load_wasm_module:z,run_dir_detect:U(!0),run_transform:U(!1),ask_question:F}};_();const N=performance.now(),R=await WebAssembly.instantiate(t,q),$=performance.now(),B=$-N,H=B/1e3;d.load_time=B,console.log("tInstantiateStart",N,"tInstantiateEnd",$,"tInstantiate",B,"tInstantiateSeconds",H),A=R,console.log("wasmModuleInstance",R),console.log("wasmModuleInstance.exports",R.exports),console.log("wasmModuleInstance.exports.memory.buffer",R.exports.memory.buffer),console.log("wasmModuleInstance.exports.memory.buffer.byteLength",R.exports.memory.buffer.byteLength),d.memory_usage_start=R.exports.memory.buffer.byteLength;try{const e=performance.now(),o=D.start(R),t=performance.now(),r=t-e,s=r/1e3;if(d.execution_time=r,console.log("tTransformStart",e,"tTransformEnd",t,"tTransform",r,"tTransformSeconds",s),console.log("exitCode:",o),0!==o){const e=`got a non-zero exit code: ${o}`;console.error(e,"DEBUG fds:",m),self.postMessage({type:a,payload:e});break}const n=S[3]?.dir?.contents["myproject.zip"]?.data?.buffer;if(!n){self.postMessage({type:a,payload:'The output "myproject.zip" file is missing.'}),console.log("ERROR myproject.zip is missing, DEBUG fds:",m);break}self.postMessage({type:"transform-done",payload:{myprojectzip:n,tTransform:r}}),console.log("after transformation wasmModuleInstance.exports.memory.buffer.byteLength",R.exports.memory.buffer.byteLength),d.memory_usage_end=R.exports.memory.buffer.byteLength,(()=>{console.log("printMetrics start"),console.log("------------------------------------------------------------------");let e=0,o=0;u.forEach((t=>{e+=d.call_counts[t],o+=d.call_durations[t]})),d.io_count=e,d.io_time=o,console.log("calculate per transformer total times");for(const e in d.custom_transformer_times){const o=d.custom_transformer_times[e];o.tLoad=o.tCompile+o.tInstantiate+o.tStart,o.tExec=o.tAllocate+o.tDirDetect+o.tTransform}console.log("METRICS",JSON.stringify(d,null,4)),console.log("------------------------------------------------------------------"),console.log("printMetrics end")})()}catch(e){console.error("the wasm module finished with an error:",e,"DEBUG fds:",m);const o=`${e}`;self.postMessage({type:a,payload:o})}break}default:throw new Error(`unknown message type: ${o.type}`)}}catch(e){console.error("failed to process the message. error:",e)}console.log("processMessage end")};(()=>{const e=console.log;console.log=(...o)=>e("[worker]",...o);const o=console.error;console.error=(...e)=>o("[worker]",...e),console.log("main start"),self.addEventListener("message",h),console.log("main end")})()}},r={};function s(e){var o=r[e];if(void 0!==o)return o.exports;var n=r[e]={exports:{}};return t[e](n,n.exports,s),n.exports}s.m=t,s.x=()=>{var e=s.O(void 0,[152],(()=>s(408)));return s.O(e)},e=[],s.O=(o,t,r,n)=>{if(!t){var a=1/0;for(m=0;m<e.length;m++){for(var[t,r,n]=e[m],l=!0,c=0;c<t.length;c++)(!1&n||a>=n)&&Object.keys(s.O).every((e=>s.O[e](t[c])))?t.splice(c--,1):(l=!1,n<a&&(a=n));if(l){e.splice(m--,1);var i=r();void 0!==i&&(o=i)}}return o}n=n||0;for(var m=e.length;m>0&&e[m-1][2]>n;m--)e[m]=e[m-1];e[m]=[t,r,n]},s.d=(e,o)=>{for(var t in o)s.o(o,t)&&!s.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:o[t]})},s.f={},s.e=e=>Promise.all(Object.keys(s.f).reduce(((o,t)=>(s.f[t](e,o),o)),[])),s.u=e=>e+".bundle.js",s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,o)=>Object.prototype.hasOwnProperty.call(e,o),(()=>{var e;s.g.importScripts&&(e=s.g.location+"");var o=s.g.document;if(!e&&o&&(o.currentScript&&(e=o.currentScript.src),!e)){var t=o.getElementsByTagName("script");if(t.length)for(var r=t.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=t[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),s.p=e})(),(()=>{var e={408:1};s.f.i=(o,t)=>{e[o]||importScripts(s.p+s.u(o))};var o=self.webpackChunkmove2kube_wasm=self.webpackChunkmove2kube_wasm||[],t=o.push.bind(o);o.push=o=>{var[r,n,a]=o;for(var l in n)s.o(n,l)&&(s.m[l]=n[l]);for(a&&a(s);r.length;)e[r.pop()]=1;t(o)}})(),o=s.x,s.x=()=>s.e(152).then(o),s.x()})();